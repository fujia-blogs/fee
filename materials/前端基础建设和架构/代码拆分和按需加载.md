# 代码拆分和按需加载

1，事实上，代码拆分和按需加载的设计决定着⼯程化构建的结果，这将直接影响应⽤的性能表现，因为合理的加载时机和代码拆分能够使初始代码体积更⼩，⻚⾯加载更快

2，如何合理设计代码拆分和按需加载，是对⼀个项⽬架构情况的直接考量

## 代码拆分和按需加载场景

### 按需加载 VS 按需打包

1，按需加载表示代码模块在交互需要时，动态引⼊

2，按需打包针对第三⽅依赖库，及业务模块，只打包真正在运⾏时可能会需要的代码

### Tree sharking 实现按需打包

1，组件库提供了 ES Module 版本，并开启了 Tree Shaking，我们就可以通过“摇树”特性，将不会被使⽤的代码在构建阶段移除

- webpack 可以在 package.json 中设置 sideEffects: false
- **指定副作⽤模块⸺这是⼀种值得推荐的开发习惯**，建议你注意 Tree Shaking 的使⽤，最好实际观察⼀下打包结果

### dynamic import(动态导入)

1，dynamic import 的提案早已横空出世，⽬前已经进⼊了 stage 4 阶段

#### 静态导入的性能优劣

1，标准⽤法的 import 属于静态导⼊，它只⽀持⼀个字符串类型的 module specifier（模块路径声明），这样的特性会使所有被 import 的模块在加载时就被编译。从某些⻆度看，这种做法对于绝⼤多数场景来说性能是友好的，因为这意味着对⼯程代码的静态分析成为可能，进⽽使得类似 tree-shaking 的技术有了应⽤空间

2，对于⼀些特殊场景，静态导⼊也可能成为性能的短板，如：

- 按需加载一个模块
- 按运行事件选定一个模块

具体如：如在浏览器侧，根据⽤户的系统语⾔选择加载不同的语⾔模块，根据⽤户的操作去加载不同的内容逻辑。

### webpack 代码拆分和按需加载

1，Webpack 提供了三种相关能⼒：

- 通过入口配置手动分割代码
- 动态导入支持
- 通过 splitChunk 插件提取公共代码

#### webpack 支持 dynamic import

1，调⽤ import()，被请求的模块和它引⽤的所有⼦模块，会分离到⼀个单独的 chunk 中

2，值得学习的是，Webpack 对于 import() 的⽀持和处理⾮常“巧妙”，我们知道 ES 中关于 dynamic import 的规范，只接受⼀个参数，表示模块的路径，但是 Webpack 是⼀个构建⼯具，Webpack 中对于 import() 的处理，可以通过注释接收⼀些特殊的参数，⽆须破坏 ES 对于 dynamic import 规定

- Webpack 在构建时，可以读取到 import 参数，即便是参数内的注释部分，Webpack 也可以获取并处理

### webpack 中的 splitChunk

1，Webpack splitChunk 插件满⾜下述条件时，⾃动进⾏代码分割：

- 可以被共享的(即重复被引用的)模块或者 node_modules 中的模块
- 在压缩前体积大于 30kb 的模块
- 在按需加载模块时，并⾏加载的模块不得超过 5 个
- 在⻚⾯初始化加载时，并⾏加载的模块不得超过 3 个

**注意的是，关于 splitChunk 插件的默认参数是 Webpack 团队所设定的通⽤性优化⼿段，是经过“千挑万选”确定的，因此适⽤于多数开发场景。如果在没有实践测量的情况下，不建议开发者⼿动优化这些参数**

## 知识点

1，⽬前按需打包⼀般通过两种⽅式进⾏：

- 使用 ES Module 支持的 Tree Sharking 方案，在使用构建工具打包时，完成按需打包
- 使用 babel-plugin-import 为主的 babel 插件，实现自动按需打包

2，babel 内置了几个核心分析，操作 ast 的工具集，babel 插件通过观察者+访问者模式，对 ast 节点统一遍历，因此具备良好的扩展性和灵活性

3，表⾯上看，await import() 的⽤法使得 import 像⼀个函数，该函数通过 () 操作符调⽤并返回⼀个 Promise。事实上，dynamic import 只是⼀个 function like 的语法形式。

4，在 ES class 特性中，super() 与 dynamic import 类似，也是⼀个 function like 语法形式

5，dynamic import 和函数的本质区别：

- dynamic import 并⾮继承⾃ Function.prototype，因此不能使⽤ Function 构造函数原型上的⽅法 impoort.call(null, ${path})，调⽤它是不合法的
- dynamic import 并⾮继承⾃ Object.prototype，因此不能使⽤ Object 构造函数原型上的⽅法

6，**代码拆分和按需加载并不完全是⼯程化的实施，同时也要求对语⾔深刻掌握**

7，代码分割区别于动态加载，它们本质上是两个概念

- dynamic import（动态导⼊）技术本质上⼀种是懒加载⸺按需加载，即只有在需要的时候，才加载代码。⽽以 splitChunk 插件为代表的代码分割，是⼀种代码拆包技术，与代码合并打包是⼀个相逆的过程

**代码分割的核心意义：避免重复打包以及提升缓存利用率，进而提升访问速度**
