# 同构渲染 SSR 应用

## 问答

1，同构应⽤不就是调⽤⼀个 renderToString（React 中）类似的 API 吗？

拿⾯试来说，同构应⽤的考察点不是“纸上谈兵”的理论，⽽是实际实施时的细节

2，为什么我们要编译源码呢？

业务源码中，我们使⽤ ESM 编写 React 和 Redux 代码，对于低版本 Node.js 来说，并不能直接⽀持 ESM 规范，因此需要使⽤ Babel 将 src/⽂件夹内代码编译到 views/⽬录中

3，React dangerouslySetInnerHTML API 也有类似⻛险，React 是怎么处理这个安全隐患的呢？

4，isomorphic-style-loader 的原理是什么呢？

对于 Webpack 来说，所有的资源都是模块。WebpackLoader 在编译过程中可以将导⼊的 CSS ⽂件转换成对象，拿到样式信息。因此 isomorphic-style-loader 可以获取⻚⾯中所有组件样式。为了实现得
更加通⽤化，isomorphic-style-loader 利⽤ context API，在渲染⻚⾯组件时获取所有 React 组件的样式信
息，最终插⼊ HTML 字符串中。

## 要点

### 同构应⽤中你容易忽略的细节

1，环境区分

- 同构应⽤实现了客户端代码和服务端代码的基本统⼀，我们只需要编写⼀种组件，就能⽣成适⽤于服务端和客户端的组件案例
- ⼤多数情况下服务端代码和客户端代码需要单独处理

2，路由代码差别

服务端需要根据请求路径，匹配⻚⾯组件；客户端需要通过浏览器中的地址，匹配⻚⾯组件

3，打包差别

### 安全问题

1，安全问题⾮常关键，尤其是涉及服务端渲染，开发者要格外⼩⼼

2，需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符。我习惯使⽤ serialize-javascript 库进⾏处理，这也是同构应⽤中最容易被忽视的细节

### 请求认证处理

1，⼀个场景：某个请求依赖 cookie 表明的⽤户信息，⽐如请
求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header 信息。这个请求在服务端发送时，⼀定不会拿到预期的结果。

解决办法也很简单：服务端请求时需要保留客户端⻚⾯请求的信息（⼀般是 cookie），并在 API 请求时携带并透传这个信息（cookie）。

### 样式问题处理

1，同构应⽤的样式处理容易被开发者忽视，⽽⼀旦忽略，就会掉到坑⾥

2，们不能再使⽤ style-loader 了，因为这个 WebpackLoader 会在编译时将样式模块载⼊到 HTML header 中。但是在服务端渲染环境下，没有 Window 对象，style-loader 就会报错。⼀般我们使⽤ isomorphic-style-loader 来实现

## 知识点

## 小结
